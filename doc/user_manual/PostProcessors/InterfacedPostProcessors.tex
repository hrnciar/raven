\subsubsection{Interfaced}
\label{Interfaced}
The \textbf{Interfaced} post-processor is a Post-Processor that allows the user
to create its own Post-Processor. While the External Post-Processor (see
Section~\ref{External} allows the user to create case-dependent
Post-Processors, with this new class the user can create new general
purpose Post-Processors.
%

\ppType{Interfaced}{Interfaced}

\begin{itemize}
  \item \xmlNode{method}, \xmlDesc{comma separated string, required field},
  lists the method names of a method that will be computed (each
  returning a post-processing value). All available methods need to be included
  in the ``/raven/framework/PostProcessorFunctions/'' folder
\end{itemize}

\textbf{Example:}
\begin{lstlisting}[style=XML,morekeywords={subType,debug,name,class,type}]
<Simulation>
  ...
  <Models>
    ...
    <PostProcessor name="example" subType='InterfacedPostProcessor'verbosity='debug'>
       <method>testInterfacedPP</method>
       <!--Here, the xml nodes required by the chosen method have to be
       included.
        -->
    </PostProcessor>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}

All the \textbf{Interfaced} post-processors need to be contained in the
``/raven/framework/PostProcessorFunctions/'' folder. In fact, once the
\textbf{Interfaced} post-processor is defined in the RAVEN input file, RAVEN
search that the method of the post-processor is located in such folder.

The class specified in the \textbf{Interfaced} post-processor has to inherit the
PostProcessorInterfaceBase class and the user must specify this set of
methods:
\begin{itemize}
  \item initialize: in this method, the internal parameters of the
  post-processor are initialized. Mandatory variables that needs to be
  specified are the following:
\begin{itemize}
  \item self.inputFormat: type of dataObject expected in input
  \item self.outputFormat: type of dataObject generated in output
\end{itemize}
  \item readMoreXML: this method is in charge of reading the PostProcessor xml
  node, parse it and fill the PostProcessor internal variables.
  \item run: this method performs the desired computation of the dataObject.
\end{itemize}

\begin{lstlisting}[language=python]
from PostProcessorInterfaceBaseClass import PostProcessorInterfaceBase
class testInterfacedPP(PostProcessorInterfaceBase):
  def initialize(self)
  def readMoreXML(self,xmlNode)
  def run(self,inputDic)
\end{lstlisting}

\paragraph{Data Format}
The user is not allowed to modify directly the DataObjects, however the
content of the DataObjects is available in the form of a python dictionary.
Both the dictionary give in input and the one generated in the output of the
PostProcessor are structured as follows:

\begin{lstlisting}[language=python]
inputDict = {'data':{}, 'metadata':{}}
\end{lstlisting}

where:

\begin{lstlisting}[language=python]
inputDict['data'] = {'input':{}, 'output':{}}
\end{lstlisting}

In the input dictonary, each input variable is listed as a dictionary that
contains a numpy array with its own values as shown below for a simplified
example

\begin{lstlisting}[language=python]
inputDict['data']['input'] = {'inputVar1': array([ 1.,2.,3.]),
                              'inputVar2': array([4.,5.,6.])}
\end{lstlisting}

Similarly, if the dataObject is a PointSet then the output dictionary is
structured as follows:

\begin{lstlisting}[language=python]
inputDict['data']['output'] = {'outputVar1': array([ .1,.2,.3]),
                               'outputVar2':array([.4,.5,.6])}
\end{lstlisting}

Howevers, if the dataObject is a HistorySet then the output dictionary is
structured as follows:

\begin{lstlisting}[language=python]
inputDict['data']['output'] = {'hist1': {}, 'hist2':{}}
\end{lstlisting}

where

\begin{lstlisting}[language=python]
inputDict['output']['data'][hist1] = {'time': array([ .1,.2,.3]),
                              'outputVar1':array([ .4,.5,.6])}
inputDict['output']['data'][hist2] = {'time': array([ .1,.2,.3]),
                              'outputVar1':array([ .14,.15,.16])}
\end{lstlisting}


\paragraph{Method: HStoPSOperator}

This Post-Processor performs the conversion from HistorySet to PointSet performing a projection of the output space.

In the \xmlNode{PostProcessor} input block, the following XML sub-nodes are available:

\begin{itemize}
   \item \xmlNode{pivotParameter}, \xmlDesc{string, optional field}, ID of the temporal variable. Default is ``time''.
   \nb Used just in case the  \xmlNode{pivotValue}-based operation  is requested
    \item \xmlNode{operator}, \xmlDesc{string, optional field}, the operation to perform on the output space:
      \begin{itemize}
        \item \textbf{min}, compute the minimum of each variable along each single history
         \item \textbf{max}, compute the maximum of each variable along each single history
         \item \textbf{average}, compute the average of each variable along each single history
         \item \textbf{all}, join together all of the each variable in
           the history, and make the pivotParameter a regular
           parameter.  Unlike the min and max operators, this keeps
           all the data, just organized differently. This operator
           does this by propogating the other input parameters for
           each item of the pivotParameter.
           Table~\ref{operator_all_switch_before} shows an example
           HistorySet with input parameter x, pivot parameter t, and
           output parameter b and then
           Table~\ref{operator_all_switch_after} shows the resulting
           PointSet with input parameters x and t, and output
           parameter b. Note that which parameters are input and which
           are output in the resulting PointSet depends on the
           DataObject specification.
       \end{itemize}
        \nb This node can be inputted only if \xmlNode{pivotValue} and \xmlNode{row} are not present
     \item \xmlNode{pivotValue}, \xmlDesc{float, optional field}, the value of the pivotParameter with respect to the other outputs need to be extracted.
       \nb This node can be inputted only if \xmlNode{operator} and \xmlNode{row} are not present
     \item \xmlNode{pivotStrategy}, \xmlDesc{string, optional field}, The strategy to use for the pivotValue:
       \begin{itemize}
        \item \textbf{nearest}, find the value that is the nearest with respect the \xmlNode{pivotValue}
        \item \textbf{floor}, find the value that is the nearest with respect to the \xmlNode{pivotValue} but less then the  \xmlNode{pivotValue}
        \item \textbf{celing}, find the value that is the nearest with respect to the \xmlNode{pivotValue} but greater then the  \xmlNode{pivotValue}
        \item \textbf{interpolate}, if the exact  \xmlNode{pivotValue}  can not be found, interpolate using a linear approach
       \end{itemize}

       \nb Valid just in case \xmlNode{pivotValue} is present
     \item \xmlNode{row}, \xmlDesc{int, optional field}, the row index at which the outputs need to be extracted.
       \nb This node can be inputted only if \xmlNode{operator} and \xmlNode{pivotValue} are not present
\end{itemize}

This example will show how the XML input block would look like:

\begin{lstlisting}[style=XML,morekeywords={subType,debug,name,class,type}]
<Simulation>
  ...
  <Models>
    ...
    <PostProcessor name="HStoPSperatorRows" subType="InterfacedPostProcessor">
      <method>HStoPSOperator</method>
      <row>-1</row>
    </PostProcessor>
    <PostProcessor name="HStoPSoperatorPivotValues" subType="InterfacedPostProcessor">
        <method>HStoPSOperator</method>
        <pivotParameter>time</pivotParameter>
        <pivotValue>0.3</pivotValue>
    </PostProcessor>
    <PostProcessor name="HStoPSoperatorOperatorMax" subType="InterfacedPostProcessor">
        <method>HStoPSOperator</method>
        <pivotParameter>time</pivotParameter>
        <operator>max</operator>
    </PostProcessor>
    <PostProcessor name="HStoPSoperatorOperatorMin" subType="InterfacedPostProcessor">
        <method>HStoPSOperator</method>
        <pivotParameter>time</pivotParameter>
        <operator>min</operator>
    </PostProcessor>
    <PostProcessor name="HStoPSoperatorOperatorAverage" subType="InterfacedPostProcessor">
        <method>HStoPSOperator</method>
        <pivotParameter>time</pivotParameter>
        <operator>average</operator>
    </PostProcessor>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}

\begin{table}[!hbtp]
  \caption{Starting HistorySet for operator all}
  \label{operator_all_switch_before}
\begin{tabular}{l|l|l}
  x & t & b \\
  \hline
  5.0 &  &  \\
  \hline
  & 1.0 & 6.0 \\
  \hline
  & 2.0 & 7.0 \\
\end{tabular}
\end{table}

\begin{table}[!hbtp]
  \caption{Resulting PointSet after operator all}
  \label{operator_all_switch_after}
\begin{tabular}{l|l|l}
  x & t & b \\
  \hline
  5.0 & 1.0 & 6.0  \\
  \hline
  5.0 & 2.0 & 7.0 \\
\end{tabular}
\end{table}

\paragraph{Method: HistorySetSampling}
This Post-Processor performs the conversion from HistorySet to HistorySet
The conversion is made so that each history H is re-sampled accordingly  to a
specific sampling strategy.
It can be used to reduce the amount of space required by the HistorySet.

In the \xmlNode{PostProcessor} input block, the following XML sub-nodes are required,
independent of the \xmlAttr{subType} specified:

\begin{itemize}
   \item \xmlNode{samplingType}, \xmlDesc{string, required field}, specifies the type of sampling method to be used:
   \begin{itemize}
     \item uniform: the set of \xmlNode{numberOfSamples} samples are uniformly distributed along the time axis
     \item firstDerivative: the set of \xmlNode{numberOfSamples} samples are distributed along the time axis in regions with
                            higher first order derivative
     \item secondDerivative: the set of \xmlNode{numberOfSamples} samples are distributed along the time axis in regions with
                             higher second order derivative
     \item filteredFirstDerivative: samples are located where the first derivative is greater than the specified \xmlNode{tolerance} value
                                    (hence, the number of samples can vary from history to history)
     \item filteredSecondDerivative: samples are located where the second derivative is greater than the specified \xmlNode{tolerance} value
                                     (hence, the number of samples can vary from history to history)
   \end{itemize}
   \item \xmlNode{numberOfSamples}, \xmlDesc{integer, optional field}, number of samples (required only for the following sampling
                                             types: uniform, firstDerivative secondDerivative)
   \item \xmlNode{pivotParameter}, \xmlDesc{string, required field}, ID of the temporal variable
   \item \xmlNode{interpolation}, \xmlDesc{string, optional field}, type of interpolation to be employed for the history reconstruction
                                           (required only for the following sampling types: uniform, firstDerivative secondDerivative).
                                           Valid types of interpolation to specified: linear, nearest, zero, slinear, quadratic, cubic, intervalAverage
   \item \xmlNode{tolerance}, \xmlDesc{string, optional field}, tolerance level (required only for the following sampling types:
                                       filteredFirstDerivative or filteredSecondDerivative)
\end{itemize}

\paragraph{Method: HistorySetSync}
This Post-Processor performs the conversion from HistorySet to HistorySet
The conversion is made so that all histories are synchronized in time.
It can be used to allow the histories to be sampled at the same time instant.

There are two possible synchronization methods, specified through the \xmlNode{syncMethod} node.  If the
\xmlNode{syncMethod} is \xmlString{grid}, a \xmlNode{numberOfSamples} node is specified,
which yields an equally-spaced grid of time points. The output values for these points will be linearly derived
using nearest sampled time points, and the new HistorySet will contain only the new grid points.

The other methods are used by specifying \xmlNode{syncMethod} as \xmlString{all}, \xmlString{min}, or
\xmlString{max}.  For \xmlString{all}, the postprocessor will iterate through the
existing histories, collect all the time points used in any of them, and use these as the new grid on which to
establish histories, retaining all the exact original values and interpolating linearly where necessary.
In the event of \xmlString{min} or \xmlString{max}, the postprocessor will find the smallest or largest time
history, respectively, and use those time values as nodes to interpolate between.

In the \xmlNode{PostProcessor} input block, the following XML sub-nodes are required,
independent of the \xmlAttr{subType} specified:

\begin{itemize}
   \item \xmlNode{pivotParameter}, \xmlDesc{string, required field}, ID of the temporal variable
   \item \xmlNode{extension}, \xmlDesc{string, required field}, type of extension when the sync process goes outside the boundaries of the history (zeroed or extended)
   \item \xmlNode{syncMethod}, \xmlDesc{string, required field}, synchronization strategy to employ (see
     description above).  Options are \xmlString{grid}, \xmlString{all}, \xmlString{max}, \xmlString{min}.
   \item \xmlNode{numberOfSamples}, \xmlDesc{integer, optional field}, required if \xmlNode{syncMethod} is
     \xmlString{grid}, number of new time samples
\end{itemize}

\paragraph{Method: HistorySetSnapShot}
This Post-Processor performs a conversion from HistorySet to PointSet.
The conversion is made so that each history $H$ is converted to a single point $P$.
There are several methods that can be employed to choose the single point from the history:
\begin{itemize}
  \item min: Take a time slice when the \xmlNode{pivotVar} is at its smallest value,
  \item max: Take a time slice when the \xmlNode{pivotVar} is at its largest value,
  \item average: Take a time slice when the \xmlNode{pivotVar} is at its time-weighted average value,
  \item value: Take a time slice when the \xmlNode{pivotVar} \emph{first passes} its specified value,
  \item timeSlice: Take a time slice index from the sampled time instance space.
\end{itemize}
To demonstrate the timeSlice, assume that each history H is a dict of n output variables $x_1=[...],
x_n=[...]$, then the resulting point P is at time instant index t: $P=[x_1[t],...,x_n[t]]$.

Choosing one the these methods for the \xmlNode{type} node will take a time slice for all the variables in the
output space based on the provided parameters.  Alternatively, a \xmlString{mixed} type can be used, in which
each output variable can use a different time slice parameter.  In other words, you can take the max of one
variable while taking the minimum of another, etc.

In the \xmlNode{PostProcessor} input block, the following XML sub-nodes are required,
independent of the \xmlAttr{subType} specified:

\begin{itemize}
  \item \xmlNode{type}, \xmlDesc{string, required field}, type of operation: \xmlString{min}, \xmlString{max},
                        \xmlString{average}, \xmlString{value}, \xmlString{timeSlice}, or \xmlString{mixed}
   \item \xmlNode{extension}, \xmlDesc{string, required field}, type of extension when the sync process goes outside the boundaries of the history (zeroed or extended)
   \item \xmlNode{pivotParameter}, \xmlDesc{string, optional field}, name of the temporal variable.  Required for the
     \xmlString{average} and \xmlString{timeSlice} methods.
\end{itemize}

If a \xmlString{timeSlice} type is in use, the following nodes also are required:
\begin{itemize}
   \item \xmlNode{timeInstant}, \xmlDesc{integer, required field}, required and only used in the
     \xmlString{timeSlice} type.  Location of the time slice (integer index)
   \item \xmlNode{numberOfSamples}, \xmlDesc{integer, required field}, number of samples
\end{itemize}

If instead a \xmlString{min}, \xmlString{max}, \xmlString{average}, or \xmlString{value} is used, the following nodes
are also required:
\begin{itemize}
   \item \xmlNode{pivotVar}, \xmlDesc{string, required field},  Name of the chosen indexing variable (the
         variable whose min, max, average, or value is used to determine the time slice)
       \item \xmlNode{pivotVal}, \xmlDesc{float, optional field},  required for \xmlString{value} type, the value for the chosen variable
\end{itemize}

Lastly, if a \xmlString{mixed} approach is used, the following nodes apply:
\begin{itemize}
  \item \xmlNode{max}, \xmlDesc{string, optional field}, the names of variables whose output should be their
    own maximum value within the history.
  \item \xmlNode{min}, \xmlDesc{string, optional field}, the names of variables whose output should be their
    own minimum value within the history.
  \item \xmlNode{average}, \xmlDesc{string, optional field}, the names of variables whose output should be their
    own average value within the history. Note that a \xmlNode{pivotParameter} node is required to perform averages.
  \item \xmlNode{value}, \xmlDesc{string, optional field}, the names of variables whose output should be taken
    at a time slice determined by another variable.  As with the non-mixed \xmlString{value} type, the first
    time the \xmlAttr{pivotVar} crosses the specified \xmlAttr{pivotVal} will be the time slice taken.
    This node requires two attributes, if used:
    \begin{itemize}
      \item \xmlAttr{pivotVar}, \xmlDesc{string, required field}, the name of the variable on which the time
        slice will be performed.  That is, if we want the value of $y$ when $t=0.245$,
        this attribute would be \xmlString{t}.
      \item \xmlAttr{pivotVal}, \xmlDesc{float, required field}, the value of the \xmlAttr{pivotVar} on which the time
        slice will be performed.  That is, if we want the value of $y$ when $t=0.245$,
        this attribute would be \xmlString{0.245}.
    \end{itemize}
  Note that all the outputs of the \xmlNode{DataObject} output of this postprocessor must be listed under one
  of the \xmlString{mixed} node types in order for values to be returned.
\end{itemize}

\textbf{Example (mixed):}
This example will output the average value of $x$ for $x$, the value of $y$ at
time$=0.245$ for $y$, and the value of $z$ at $x=4.0$ for $z$.
\begin{lstlisting}[style=XML,morekeywords={subType,debug,name,class,type}]
<Simulation>
  ...
  <Models>
    ...
    <PostProcessor name="mampp2" subType="InterfacedPostProcessor">
      <method>HistorySetSnapShot</method>
      <type>mixed</type>
      <average>x</average>
      <value pivotVar="time" pivotVal="0.245">y</value>
      <value pivotVar="x" pivotVal="4.0">z</value>
      <pivotParameter>time</pivotParameter>
      <extension>zeroed</extension>
    </PostProcessor>
    ...
  </Models>
  ...
</Simulation>
\end{lstlisting}


\paragraph{Method: HS2PS}

This Post-Processor performs a conversion from HistorySet to PointSet.
The conversion is made so that each history $H$ is converted to a single point $P$.
Assume that each history $H$ is a dict of $n$ output variables $x_1=[...],x_n=[...]$, then the resulting point $P$ is $P=concat(x_1,...,x_n)$.
Note: it is here assumed that all histories have been sync so that they have the same length, start point and end point. If you are not sure, do a pre-processing the the original history set.

In the \xmlNode{PostProcessor} input block, the following XML sub-nodes are required,
independent of the \xmlAttr{subType} specified (min, max, avg and value case):

\begin{itemize}
   \item \xmlNode{pivotParameter}, \xmlDesc{string, optional field}, ID of the temporal variable (only for avg)
\end{itemize}

\paragraph{Method: TypicalHistoryFromHistorySet}
This Post-Processor performs a simplified procedure of \cite{wilcox2008users} to form a ``typical'' time series from multiple time series. The input should be a HistorySet, with each history in the HistorySet synchronized. For HistorySet that is not synchronized, use Post-Processor method \textbf{HistorySetSync}  to synchronize the data before running this method.

Each history in input HistorySet is first converted to multiple histories each has maximum time specified in \xmlNode{outputLen} (see below). Each converted history $H_i$ is divided into a set of subsequences $\{H_i^j\}$, and the division is guided by the \xmlNode{subseqLen} node specified in the input XML. The value of \xmlNode{subseqLen} should be a list of positive numbers that specify the length of each subsequence. If the number of subsequence for each history is more than the number of values given in \xmlNode{subseqLen}, the values in \xmlNode{subseqLen} would be reused.

For each variable $x$, the method first computes the empirical CDF (cumulative density function) by using all the data values of $x$ in the HistorySet. This CDF is termed as long-term CDF for $x$. Then for each subsequence $H_i^j$, the method computes the empirical CDF by using all the data values of $x$ in $H_i^j$. This CDF is termed as subsequential CDF. For the first interval window (i.e., $j=1$), the method computes the Finkelstein-Schafer (FS) statistics \cite{finkelstein1971improved} between the long term CDF and the subsequential CDF of $H_i^1$ for each $i$. The FS statistics is defined as following.
\begin{align*}
FS & = \sum_x FS_x\\
FS_x &= \frac{1}{N}\sum_{n=1}^N\delta_n
\end{align*}
where $N$ is the number of value reading in the empirical CDF and $\delta_n$ is the absolute difference between the long term CDF and the subsequential CDF at value $x_n$. The subsequence $H_i^1$ with minimal FS statistics will be selected as the typical subsequence for the interval window $j=1$. Such process repeats for $j=2,3,\dots$ until all subsequences have been processed. Then all the typical subsequences will be concatenated to form a complete history.

In the \xmlNode{PostProcessor} input block, the following XML sub-nodes are required,
independent of the \xmlAttr{subType} specified:

\begin{itemize}
   \item \xmlNode{pivotParameter}, \xmlDesc{string, optional field}, ID of the temporal variable
   \default{Time}
   \item \xmlNode{subseqLen}, \xmlDesc{integers, required field}, length of the divided subsequence (see above)
   \item \xmlNode{outputLen}, \xmlDesc{integer, optional field}, maximum value of the temporal variable for the generated typical history
   \default{Maximum value of the variable with name of \xmlNode{pivotParameter}}
\end{itemize}

For example, consider history of data collected over three years in one-second increments,
where the user wants a single \emph{typical year} extracted from the data.
The user wants this data constructed by combining twelve equal \emph{typical month}
segments.  In this case, the parameter \xmlNode{outputLen} should be \texttt{31536000} (the number of seconds
in a year), while the parameter \xmlNode{subseqLen} should be \texttt{2592000} (the number of seconds in a
month).  Using a value for \xmlNode{subseqLen} that is either much, much smaller than \xmlNode{outputLen} or
of equal size to \xmlNode{outputLen} might have unexpected results.  In general, we recommend using a
\xmlNode{subseqLen} that is roughly an order of magnitude smaller than \xmlNode{outputLen}.

\paragraph{Method: dataObjectLabelFilter}
This Post-Processor allows to filter the portion of a dataObject, either PointSet or HistorySet, with a given clustering label.
A clustering algorithm associates a unique cluster label to each element of the dataObject (PointSet or HistorySet).
This cluster label is a natural number ranging from $0$ (or $1$ depending on the algorithm) to $N$ where $N$ is the number of obtained clusters.
Recall that some clustering algorithms (e.g., K-Means) receive $N$ as input while others (e.g., Mean-Shift) determine $N$ after clustering has been performed.
Thus, this Post-Processor is naturally employed after a data-mining clustering techniques has been performed on a dataObject so that each clusters
can be analyzed separately.

In the \xmlNode{PostProcessor} input block, the following XML sub-nodes are required,
independently of the \xmlAttr{subType} specified:

\begin{itemize}
   \item \xmlNode{label}, \xmlDesc{string, required field}, name of the clustering label
   \item \xmlNode{clusterIDs}, \xmlDesc{integers, required field}, ID of the selected clusters. Note that more than one ID can be provided as input
\end{itemize}
